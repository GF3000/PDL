#MAIN

cadena = input()
pila = [0]

while True:

	estado_futuro = pila[-1]
	
	token = cadena[0]
	accion, argumento = ACCION(elemento, token)
	swicth (accion):

		case REDUCE:
			regla = REGLAS(argumento)
			repeat 2*len(regla.derecha):
				pila.pop()
			pila.append(regla.izquierda) 
			self.pila.append(self.GOTO(self.pila[-2], regla.izquierda))

		case SHIFT:
			pila.append(cadena[0])
			cadena = cadena [1:]
			pila.append(argumento)

		caso EXITO:
			return EXITO

		defeault:
			return FALLO


#ESTRUCTURAS Y FUNCIONES AUXILIARES

listado_REGLAS = [REGLA1, REGLA2, REGLA3, ...]
tabla_GOTO = {ESTADO1 {NO_TERMINAL1: estado_futuro, NO_TERMINAL2: estado_futuro, ...}, ESTADO2: {...}, ESTADO3: {...}, ...}
tabla_ACCION = {ESTADO1: {TOKEN1: [accion, argumento], TOKEN2: [accion, argumento], ...}, ESTADO2: {...}, ESTADO3: {...}, ...}
#accion = REDUCE | SHIFT | EXITO 



def GOTO(no_terminal, estado): -> estado
	#Con manjadores de excepción
	return elemento tabla_GOTO[estado][no_terminal]

def ACCION (estado, token): -> accion, argumento
	#Con manjadores de excepción
	return tabla_ACCION[estado][token][0], tabla_ACCION[estado][token][1]

def REGLA(numero_de_regla): -> regla
	#Con manjadores de excepción
	return listado_REGLAS[numero_de_regla] 

class REGLA:
	var izquierda = simbolo de la izquierda
	var derecha = [producciones]
